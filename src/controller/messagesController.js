import { db } from "../config/firebase.js";
import translateController from "./translateController.js";
import Chat from "../models/chat.js";
import admin from "firebase-admin";
import User from "../models/user.js";
import Message from "../models/message.js";

const checkExistingChat = async (req, res) => {
    try {
        const { receiverId, senderId } = req.body;
        console.log("checkExistingChat", receiverId, senderId)
        let chat = await Chat.findOne({ participants: { $all: [senderId, receiverId] } });
        if (!chat) {
            return res.status(400).json({ error: "Kh√¥ng t·ªìn t·∫°i cu·ªôc tr√≤ chuy·ªán" });
        }
        res.status(201).json({ chatId: chat._id });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
}

const handleCreateChat = async (req, res) => {
    try {
        const { receiverId, senderId, content } = req.body;
        if (!receiverId || !senderId || !content) {
            return res.status(400).json({ error: "Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc" });
        }

        let translatedContent = content;
        console.log("üìå N·ªôi dung g·ªëc:", content);

        // X√°c ƒë·ªãnh ng√¥n ng·ªØ
        let detectedLang = await detectLanguage(content);

        // N·∫øu l√† ti·∫øng Vi·ªát, d·ªãch sang ti·∫øng Anh
        if (detectedLang === "vi") {
            translatedContent = await translateController.translate(content, "en", "vi");
            console.log("üìå ƒê√£ d·ªãch sang EN:", translatedContent);
        } else {
            console.log("üìå N·ªôi dung l√† ti·∫øng Anh, kh√¥ng d·ªãch.");
        }


        // let translatedContent = content;
        // console.log("Content tr∆∞·ªõc khi d·ªãch:", content);
        // if (/[\u00C0-\u1EF9]/.test(content)) {
        //     translatedContent = await translateController.translate(content, "en", "vi");
        // }
        // console.log("Content tr∆∞·ªõc khi d·ªãch:", content);

        // Ki·ªÉm tra xem cu·ªôc tr√≤ chuy·ªán ƒë√£ t·ªìn t·∫°i trong MongoDB
        let chat = await Chat.findOne({ participants: { $all: [senderId, receiverId] } });

        if (!chat) {
            chat = new Chat({
                participants: [senderId, receiverId]
            });
            await chat.save();
        }


        const chatId = chat._id.toString();


        const newMessage = new Message({
            content,
            translatedContent,
            id_sender: senderId,
            chatId: chatId
        });
        await newMessage.save();


        const chatRef = db.collection("chat").doc(chatId);
        const chatSnapshot = await chatRef.get();

        if (!chatSnapshot.exists) {
            await chatRef.set({
                participants: [senderId, receiverId],
                createdAt: admin.firestore.FieldValue.serverTimestamp()
            });
        }

        // L∆∞u tin nh·∫Øn v√†o Firestore v·ªõi c√πng chatId
        const messageRef = chatRef.collection("messages").doc(newMessage._id.toString()); // D√πng ID tin nh·∫Øn duy nh·∫•t
        await messageRef.set({
            senderId,
            content,
            translatedContent,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        });

        console.log("T·∫°o tin nh·∫Øn th√†nh c√¥ng");
        const receiver = chat.participants.find(user => user._id.toString() !== senderId)
        if (receiver?.fcmToken) {
            const message = {
                notification: {
                    title: "New Message from ChatApp",
                    body: content
                },
                token: receiver.fcmToken
            };

            await admin.messaging().send(message);
            console.log("Notification sent!");
        }
        res.status(201).json({ message: "Chat v√† tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!", chatId: chatId });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
};



const markMessageAsRead = async (req, res) => {
    try {
        const { chatId, userId } = req.body;

        const updatedMessages = await Message.updateMany(
            { chatId, isRead: false, id_sender: { $ne: userId } }, // Ch·ªâ c·∫≠p nh·∫≠t tin nh·∫Øn ch∆∞a ƒë·ªçc c·ªßa ng∆∞·ªùi kh√°c g·ª≠i
            { isRead: true }
        );

        res.status(200).json({ message: "T·∫•t c·∫£ tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c ƒë·ªçc", updatedCount: updatedMessages.modifiedCount });
    } catch (error) {
        res.status(500).json({ message: "L·ªói khi c·∫≠p nh·∫≠t tin nh·∫Øn", error });
    }
}

const handleSendMessage = async (req, res) => {
    try {
        const { chatId, senderId, content } = req.body;
        if (!chatId || !senderId || !content) {
            return res.status(400).json({ error: "Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc" });
        }

        let translatedContent = content;
        console.log("üìå N·ªôi dung g·ªëc:", content);

        // X√°c ƒë·ªãnh ng√¥n ng·ªØ
        let detectedLang = await detectLanguage(content);

        // N·∫øu l√† ti·∫øng Vi·ªát, d·ªãch sang ti·∫øng Anh
        if (detectedLang === "vi") {
            translatedContent = await translateController.translate(content, "en", "vi");
            console.log("üìå ƒê√£ d·ªãch sang EN:", translatedContent);
        } else {
            console.log("üìå N·ªôi dung l√† ti·∫øng Anh, kh√¥ng d·ªãch.");
        }

        // let translatedContent = content;
        // console.log("Content tr∆∞·ªõc khi d·ªãch:", content);
        // if (/[\u00C0-\u1EF9]/.test(content)) {
        //     translatedContent = await translateController.translate(content, "en", "vi");
        // }
        // console.log("Content sau khi d·ªãch:", translatedContent);

        // L∆∞u tin nh·∫Øn v√†o MongoDB
        const newMessage = new Message({
            content: content,
            translatedContent: translatedContent,
            id_sender: senderId,
            chatId,
            isRead: false
        });
        const savedMessage = await newMessage.save();

        let chatRef = db.collection("chat").doc(chatId);
        await chatRef.collection("messages").add({
            id: savedMessage._id.toString(),
            senderId,
            content,
            translatedContent,
            isRead: false,
            timestamp: admin.firestore.FieldValue.serverTimestamp(),
        });

        const chat = await Chat.findById(chatId).populate("participants", "fcmToken");
        const receiver = chat.participants.find(user => user._id.toString() !== senderId)

        // if (receiver?.fcmToken) {
        //     await sendPushNotification(receiver.fcmToken, {
        //         title: "New Message from ChatApp",
        //         body: content,
        //         chatId
        //     });
        // }
        if (receiver?.fcmToken) {
            const message = {
                notification: {
                    title: "New Message from ChatApp",
                    body: content
                },
                token: receiver.fcmToken
            };

            await admin.messaging().send(message);
            console.log("Notification sent!");
        }
        res.status(201).json({
            message: "Tin nh·∫Øn ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng!",
            newMessage: savedMessage.toObject(),
        });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
};

const handleGetMessages = async (req, res) => {
    try {
        const { chatId } = req.params;

        if (!chatId) {
            return res.status(400).json({ error: "Thi·∫øu chatId" });
        }

        // L·∫•y tin nh·∫Øn t·ª´ MongoDB
        const messages = await Message.find({ chatId }).sort({ createdAt: 1 });

        res.status(200).json({
            mongoMessages: messages
        });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
};

const getMessagesFromFirestore = async (chatId) => {
    try {
        if (!chatId) {
            throw new Error("Thi·∫øu chatId");
        }

        // Truy v·∫•n Firestore
        const messageRef = db.collection("chat").doc(chatId).collection("messages");
        const snapshot = await messageRef.orderBy("timestamp", "asc").get();

        // Chuy·ªÉn d·ªØ li·ªáu th√†nh m·∫£ng
        const messages = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));

        return messages;

    } catch (error) {
        console.error("L·ªói l·∫•y tin nh·∫Øn t·ª´ Firestore:", error);
        return [];
    }
};

const getMessages = async (req, res) => {
    try {
        const { chatId } = req.params;

        if (!chatId) {
            return res.status(400).json({ error: "Thi·∫øu chatId" });
        }

        const messages = await getMessagesFromFirestore(chatId);

        res.status(200).json({ messages });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
};
const getListChat = async (req, res) => {
    try {
        const { userId } = req.params;

        if (!userId) {
            return res.status(400).json({ error: "Thi·∫øu userId" });
        }

        const chats = await Chat.find({ participants: userId })
            .sort({ createdAt: -1 })
            .populate("participants", "fullname avatar"); // L·∫•y th√¥ng tin ng∆∞·ªùi tham gia

        if (!chats.length) {
            return res.status(200).json({ listChat: [] });
        }

        const listChat = await Promise.all(chats.map(async (chat) => {
            const lastMessage = await Message.findOne({ chatId: chat._id })
                .sort({ createdAt: -1 }) // S·ª≠a l·ªói typo `createAt` th√†nh `createdAt`
                .populate("id_sender", "fullname avatar")
                .lean();

            const unreadCount = await Message.countDocuments({
                chatId: chat._id,
                id_sender: { $ne: userId },
                isRead: false
            });

            return {
                chatId: chat._id,
                participants: chat.participants.map(user => ({
                    id: user._id,
                    fullname: user.fullname,
                    avatar: user.avatar
                })), // Danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi tham gia
                lastMessage: lastMessage ? lastMessage.translatedContent : null,
                lastMessageTime: lastMessage ? lastMessage.createdAt : null,
                unreadCount: unreadCount,
                sender: lastMessage?.id_sender ? {
                    id: lastMessage.id_sender._id,
                    fullname: lastMessage.id_sender.fullname
                } : null
            }
        }));

        console.log("L·∫•y danh s√°ch chat:", listChat);

        res.status(200).json({
            listChat: listChat
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
};

const handleDeleteChat = async (req, res) => {
    try {
        const { chatId } = req.body;
        if (!chatId) {
            return res.status(400).json({ error: "Thi·∫øu chatId" });
        }
        await Chat.findByIdAndDelete(chatId);
        await Message.deleteMany({ chatId });

        const chatRef = db.collection("chat").doc(chatId);
        const messagesRef = chatRef.collection("messages");

        const messagesSnapshot = await messagesRef.get();
        const batch = db.batch();
        messagesSnapshot.forEach(doc => {
            batch.delete(doc.ref);
        });

        batch.delete(chatRef);
        await batch.commit();

        res.status(200).json({ message: "Cu·ªôc tr√≤ chuy·ªán ƒë√£ ƒë∆∞·ª£c x√≥a th√†nh c√¥ng" });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
}

const saveFCMToken = async (req, res) => {
    try {
        const { userId, fcmToken } = req.body;
        console.log("FCM TOKEN", userId, fcmToken);
        if (!userId || !fcmToken) {
            return res.status(400).json({ error: "Missing userId or fcmToken" })
        }

        const user = await User.findOneAndUpdate({ id: userId }, { fcmToken }, { new: true });
        console.log("User sau khi c·∫≠p nh·∫≠t:", user);
        res.status(200).json({ message: "FCM Token ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t" });

    } catch (error) {
        console.error(error);
        res.status(500).json({ error: "L·ªói server" });
    }
}
export default {
    handleSendMessage, handleCreateChat, handleGetMessages, getMessages,
    getListChat, checkExistingChat, handleDeleteChat, saveFCMToken
};
